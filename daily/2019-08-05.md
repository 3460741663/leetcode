# 每日一题 105. 从前序与中序遍历序列构造二叉树

## 信息卡片

* 时间：2019-08-05
* 题目链接： https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
* tag：二叉树  
## 题目描述
```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7
```
## 参考答案
递归构造二叉树，时间复杂度O(n)
>
前序可以确定根，通过根可以将中序划分成左、右子树。依次类推，前序的下一个节点可以将左子树分成左子树、右子树，将右子树分成左子树、右子树...
```c
struct TreeNode* _buildTree(int* preorder, int* pindex, int* inorder, int inbegin, int inend)
{
    if(inbegin>inend)//区间不存在，空树
    {
        return NULL;
    }
    struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode));
    root->val=preorder[*pindex];
    (*pindex)++;
    if(inbegin==inend)//区间只有一个结点，就是根结点
    {
        root->val=inorder[inbegin];
        root->left=NULL;
        root->right=NULL;
        return root;
    }
    //区间正常
    int rootindex=inbegin;
    while(rootindex<=inend)//用前序的根划分中序为两个子区间
    {
        if(inorder[rootindex]==root->val)
        {
            break;
        }
        else
        {
            ++rootindex;
        }
    }
    //递归创建左子树
    root->left= _buildTree(preorder, pindex, inorder, inbegin, rootindex-1);
    //递归创建右子树
    root->right= _buildTree(preorder, pindex, inorder, rootindex+1, inend);
    return root;
}
```
2.